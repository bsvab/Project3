<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Choropleth Map in Leaflet with Average</title>
    <!-- Load Leaflet from CDN -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <style>
        #map { height: 100vh; }

        .legend {
            line-height: 18px;
            color: #555;
            background-color: white;
            padding: 10px;
            border-radius: 10px;
            border-color: black;
        }

        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.5;
        }

        p {
            margin: 0;
            margin-bottom: 5px;
        }

        .leaflet-bottom.leaflet-left {
            width: 100%;
        }
            
        .leaflet-control-container .leaflet-timeline-controls {
            box-sizing: border-box;
            width: 100%;
            margin: 0;
            margin-bottom: 15px;
        }

    </style>
    <!-- leaflet.timeline plugin -->
    <script src="./static/leaflet.timeline.js"></script>
    <link rel="stylesheet" href="./static/leaflet.timeline.css"/>
</head>
<body>

<div id="map"></div>

<script>
    // Define the bounds of Texas
    let texasBounds = L.latLngBounds(
        [25.8371, -106.6466], // Southwest coordinates of Texas
        [36.5007, -93.5083]  // Northeast coordinates of Texas
    );

    // Create a Leaflet map centered on Texas
    let map = L.map('map').fitBounds(texasBounds);

    // Add OpenStreetMap tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Function to read CSV file
    async function readCSVFile(url) {
        const response = await fetch(url);
        const data = await response.text();
        return data;
    }

    // Call the function to read the CSV file
    readCSVFile('../../data/medium_file_test_pressure_data.csv')
        .then(data => {
            // Now you have the CSV data, you can use it here
            console.log('CSV data:', data);
            const dataset = parseCSV(data);
            console.log('Parsed dataset:', dataset);
            drawMapSquares(dataset);
        })
        .catch(error => {
            console.error('Error reading CSV:', error);
        });

    // Function to parse CSV data
    function parseCSV(csvData) {
        let dataset = [];
        // Split the CSV data into lines
        const lines = csvData.split('\n');
        // Iterate over each line
        lines.forEach(line => {
            // Split the line into comma-separated values
            const values = line.split(',');
            // Extract lat, lng, value, layer, and date from the values array
            const lat = parseFloat(values[4]);
            const lng = parseFloat(values[3]);
            const value = parseFloat(values[1]);
            const layer = values[2];
            const dateParts = values[0].split('/'); // Split date string into parts
            // Check if lat, lng, value, layer, and date are valid
            if (!isNaN(lat) && !isNaN(lng) && !isNaN(value) && dateParts.length === 3) {
                // Construct the date object
                const date = new Date(parseInt(dateParts[2]), parseInt(dateParts[0]) - 1, parseInt(dateParts[1])); // Month is 0-indexed
                // Construct the data point object
                const dataPoint = { lat, lng, value, layer, date };
                // Push the data point object to the dataset array
                dataset.push(dataPoint);
            }
        });
        return dataset;
    }

    // Function to draw 5 square mile map squares based on the dataset
    function drawMapSquares(dataset) {
        // Calculate the number of squares needed
        let width = texasBounds.getEast() - texasBounds.getWest();
        let height = texasBounds.getNorth() - texasBounds.getSouth();

        // Calculate number of squares horizontally and vertically
        let numHorizontalSquares = Math.ceil(width / (5 / 69)); // 1 degree latitude is approximately 69 miles
        let numVerticalSquares = Math.ceil(height / (5 / 69));

        // Calculate the dimensions of each square
        let squareWidth = width / numHorizontalSquares;
        let squareHeight = height / numVerticalSquares;

        // Create a dictionary to store data points for each square
        let squareData = {};

        // Iterate over each data point and assign it to the corresponding square
        dataset.forEach(point => {
            // Calculate the square index for the data point
            let xIndex = Math.floor((point.lng - texasBounds.getWest()) / squareWidth);
            let yIndex = Math.floor((texasBounds.getNorth() - point.lat) / squareHeight);
            // Create a unique key for the square
            let key = xIndex + '_' + yIndex;
            // Initialize array for the square if not exists
            if (!squareData[key]) {
                squareData[key] = [];
            }
            // Add the data point to the square
            squareData[key].push(point);
        });

        // Initialize timeline dataset as a GeoJSON FeatureCollection
        const timelineDataset = {
            type: "FeatureCollection",
            features: []
        };

        // Iterate over each square and generate timeline dataset
        Object.keys(squareData).forEach(key => {
            let points = squareData[key];

            // Group data points by layer
            const groupedByLayer = points.reduce((acc, dataPoint) => {
                const layer = dataPoint.layer;
                if (!acc[layer]) {
                    acc[layer] = [];
                }
                acc[layer].push(dataPoint);
                return acc;
            }, {});

            // Get the minimum and maximum years from the dataset
            const minYear = Math.min(...points.map(dataPoint => dataPoint.date.getFullYear()));
            const maxYear = Math.max(...points.map(dataPoint => dataPoint.date.getFullYear()));

            // Create a feature for each square
            const squareFeature = {
                type: "Feature",
                properties: {
                    squareKey: key,
                    pressures: [] // Array to store pressure values for different dates
                },
                geometry: {
                    type: "Polygon",
                    coordinates: [
                        // Define coordinates of the square here
                    ]
                }
            };

            // Iterate over each layer
            Object.keys(groupedByLayer).forEach(layer => {
                // Iterate over each year
                for (let year = minYear; year <= maxYear; year++) {
                    // Iterate over each month
                    for (let month = 0; month < 12; month++) { // 0 represents January, 11 represents December
                        // Find the closest data point to the first of the month and year
                        const closestDataPoint = points.reduce((closest, dataPoint) => {
                            const date = dataPoint.date;
                            if (date.getFullYear() === year && date.getMonth() === month) {
                                if (!closest || Math.abs(date.getDate() - 1) < Math.abs(closest.date.getDate() - 1)) {
                                    return dataPoint;
                                }
                            }
                            return closest;
                        }, null);
                        // Add the closest data point to the timeline dataset
                        if (closestDataPoint) {
                            squareFeature.properties.pressures.push({
                                layer,
                                year,
                                month: month + 1, // Adding 1 to make it 1-based month
                                date: new Date(year, month, 1),
                                value: closestDataPoint.value
                            });
                        }
                    }
                }
            });

            // Add square feature to the timeline dataset
            timelineDataset.features.push(squareFeature);
        });

        console.log('Timeline dataset:', timelineDataset);

        // Initialize Leaflet timeline control
        let timelineControl = L.timelineSliderControl({
            formatOutput: function (date) {
                return new Date(date).toDateString();
            }
        });

        // Add timeline control to the map
        timelineControl.addTo(map);

        // Add timeline dataset to the timeline control
        timelineControl.addTimelines(timelineDataset);

        // Add timeline to the map
        let timeline = L.timeline(timelineDataset, {
            style: function (data) {
                return { fillColor: getColor(data.value), color: '#000', fillOpacity: 0.5 };
            }
        }).addTo(map);
    }
</script>

</body>
</html>
